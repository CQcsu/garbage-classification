# 程序的机器级表示



**程序编码**

~~~
linux> gcc -Og -o prog main.c mstore.c
~~~

`gcc`指的是GCC编译器，它是linux系统默认编译器.

编译选项`-Og`是用来告诉编译器生成符合原始C代码整体结构的机器代码.为获得更高性能会使用`-O1`或者`-O2`，甚至更高的编译优化选项.但是使用高级别的优化产生代码会严重变形.

`-o`后面生成的参数`prog`表示生成可执行文件的文件名.

**生成汇编文件**

~~~
linux> gcc -Og -S mstore.c
~~~

`-S`编译选项就是告诉编译器`GCC`产生的文件为汇编文件，可以用vim打开这个汇编文件.

其中`.`开头的都是指导汇编器和连接器工作的伪指令，删除无关信息剩余汇编大妈与源文件C代码相关.

在x86-64的处理器中包含16个通用目的寄存器，寄存器用来存放整形数据和指针.



首先需要搞清楚两个概念**调用者保存寄存器**和**被调用者保存寄存器**：函数A调用了函数B，函数A称为调用者，函数B称为被调用者.

函数B调用前后寄存器`rbx`在函数中被修改了，逻辑上`rbx`寄存器内容在调用函数B前后应该保持一致.

1.函数A在调用函数B之前提前保存`rbx`的内容，执行完函数B后再回复`rbx`原来存储的内容，这种策略就是调用者保存.

2.函数B在使用寄存器`rbx`之前先保存`rbx`值，在函数B返回之前回复原来存储的内容，这种策略交被调用者保存.

用字(word)来表示16位的数据类型，所有32位的数据类型称为双字，64位的数据类型称为四字.

C语言基本类型汇编后缀表示：大多数GCC生成的汇编指令都有一个字符后缀来表示操作数的大小，例如mov指令:`movb`,`movw`,`movl`,`movq`.其中`movb`是传送字节的缩写.

**生成机器代码文件**

~~~
linux> gcc -Og -c mstore.c
~~~

执行这条命令，可以将`mstore.c`生成对应的机器代码文件`mstore.o`.文件是二进制格式无法直接查看。需要反汇编工具`objdump`.汇编器将汇编代码翻译成二进制机器代码，反汇编器将机器代码翻译成汇编代码.

~~~
linux> objdump -d mstore.o
~~~

左边为反汇编得到的汇编代码与编译器直接产生的汇编代码，反汇编代码省略了很多“q”,但是在`call`和`ret`后面添加q，q只是表示大小指示符，大多数情况可以省略.

**寄存器**

最早的8086处理器包含8个16位通用寄存器.

现在的64位寄存器，原来的8个16位已经扩展成了64位.还增加了8个新的寄存器

不同的寄存器扮演不同角色，例如`rax`用来保存函数的返回值.`rsp`用来保存程序栈的结束位置.

**操作数指示符**

不同指令的操作数大致可以分为3类，立即数，寄存器和内存引用.

1.立即数是`$`开头，后面跟一个整数

2.操作数是寄存器

3.寄存器带小括号是内存的引用.

常用的内存引用包含立即数，基址寄存器，变址寄存器和比例因子.

有效地址是立即数加上基址寄存器加上变址寄存器和比例因子的乘积.

mov指令包括:movb，movw，movl以及movq这4条指令.将数据从源位置复制到目的位置.主要区别在于他们操作的数据大小不同.

对于源操作数可以是立即数，寄存器，内存引用.目的操作数可以是寄存器，内存引用不能是立即数.

此外x86-64处理器,`mov`指令源操作数不能都是内存地址，需要将一个数从内存一个位置移到另一个位置需要两条`mov`指令，寄存器作为中间媒介.`mov`指令的后缀与寄存器大小一定得匹配.

`movabsq`，指令源操作数可以是任意64位立即数，注意目的操作数只能是寄存器.

`cltq`指令：源操作数总是`eax`,目的操作数总是`rax`.

**数据传送指令**

程序执行过程需要在CPU和内存之间频繁的进行数据存储.首先CPU执行数据灿松指令将a和b的值从内存读到寄存器，寄存器就是CPU的一种数据存储部件，容量较小.

用x86-64处理器，寄存器`rax`的大小64位，如果变量a是long类型，占用8个字节，rax全部数据位保存变量a，如果a是int类型，只需要4字节存储该变量低32位，如果a是short类型只需要用到寄存器低16位.

**压入和弹出栈数据**

`pushq`指令把数据压入栈分两步.

1.寄存器`rsp`值减8

2.将需要保存数据复制到栈顶地址

`popq`指令从内存中读出数据

1.栈顶位置读出数据复制到`rbx`

2.栈顶指针加8

实际上`pop`指令是通过修改栈顶指针所指向的内存地址来实现数据删除，直到下次push操作数据才会被覆盖.

**加载有效地址**

`leaq`功能是实现加载有效地址，q表示地址长度是4个字，由于x86-64位处理器是64位所有不存在其他变种.

`leaq`指令还可以实现算术运算

**条件码**

ALU除了执行算术和逻辑指令运算外，还会根据运算结果去设置条件码寄存器.

条件码寄存器由CPU来维护，单独是单个比特位，描述最近执行操作的属性.

**访问条件码**

逻辑操作指令`xor`会改变条件码

`cmp`指令根据两个操作数的差来设置条件码寄存器.

**跳转指令**

跳转指令会根据寄存器的某种组合决定是否跳转

**跳转指令的编码**

对于代码中的if else语句，当满足条件，程序沿着一条路径执行，不满足走另外一条路径，机制比较简单，但是在处理器上执行效率可能较低.

为什么基于条件传送的代码会比基于跳转指令的代码效率高？处理器通过流水线来获得高性能，当遇到条件跳转时，处理器会根据分支预测期猜测每条跳转指令是否执行，当发生错误预测时会浪费大量时间导致程序性能严重下降.

**循环**

三种形式的循环语句都是通过条件测试和跳转指令来实现的.

**switch语句**

程序使用跳转表来处理多重分支，switch有上百种情况时，虽然跳转表的长度会增加，但是程序执行也只需要跳转一次处理复杂分支情况，与一组很长的if else相比，使用跳转表的优点是switch语句的时间域case数量是无关的.所有在处理多重分支时，一组很长的if else相比，switch执行效率更高.

**过程**

大型软件构建过程中，需要对复杂功能进行切分，过程提供一种封装代码的方式，隐藏某个欣慰的具体实现，提供清晰简洁的接口定义.

**运行时栈**

程序运行时内存分布中，栈为函数调用提供了后进先出的内存管理机制.

栈帧的概念：当函数执行需要存储空间超过寄存器存放大小时，就会借助栈上的存储空间，把这部分存储空间称为函数栈帧.包括较早的帧，调用函数P的帧，怎带执行函数Q的帧.

**6转移控制**

函数P调用函数Q会吧地址压入栈中，该地址指明了函数Q执行返回结束要从函数P的那个位置继续执行，这个返回地址的压栈操作不是`push`执行，而是函数调用call来实现.

**数据传送**

如果函数参数数量大于6，超出的部分就要通过栈来传递.

1.通过栈来传递参数时，所有数据大小都是向8的倍数对齐，虽然a4变量只有一个字节，但是任然为其分配8个字节的存储空间.由于返回地址占用了栈顶的位置，所以两个参数的距离栈顶指针位置分别为8和16.

2.使用寄存器进行参数传递时，寄存器有特殊的顺序规定，此外寄存器名字使用取决于传递参数的大小.

**栈上的局部存储**

~~~c++
	long x1 = 1;
	int x2 = 2;
	short x3 = 3;
	char x4 = 4;
	proc(x1, &x1, x2, &x2, x3, &x3, x4, &x4);
~~~

`x1`占8字节，`x2`占4字节，`x3`占2字节，`x4`占1字节，所以四个变量在栈帧中空间分配.又proc需要8个参数，参数7和8通过栈帧来传递，而局部变量是不需要对齐的.

函数运行需要局部存储空间时，栈提供了内存分配与回收机制.在程序执行过程中，寄存器是被所以函数共享的资源，避免寄存器使用出现数据覆盖，处理器规定寄存器使用惯例，所有函数调用遵守这个惯例.

**递归过程**

递归调用函数本身与调用其他函数是一样的，每次函数都有自己的状态信息，栈的分配与释放规则与函数调用返回顺序也是匹配，当递归深度很大不建议使用递归调用.

**异质的数据结构**

**8.1结构体**

~~~c++
struct rec{
	int i;
	int j;
	int a[2];
	int *p;
}
~~~

各个字段相对于结构体起始地址处的字节偏移.无论是单个变量还是数组元素，都是通过起始地址加偏移量的方式来访问.

**数据对齐**

~~~c++
struct s1{
    int i;
    char c;
    int j;
}
~~~

直观认为结构体9个字节存储空间，但是`sizeof`函数对结构体求值，结果是12个字节.原因是为了提高系统性能，系统对数据存储的合法地址做了一些限制.编译器在c和j之间插入3个字节的间隙.这样整个结构体就变成了12字节.对于不同数据类型，地址对齐原则是任何K字节的基本对象地址必须是K的倍数.基于规则，编译器可能需要字段地址空间分配插入间隙，保证每个元素都满足对齐要求.

根据上述对齐原则，看一个复杂示例

~~~c++
struct res
{
	char *a;
    short b;
    double c;
    char d;
    float e;
    char f;
    long g;
    int h;
}
~~~

1、变量a是一个指针变量，占8个字节。

2、变量b是short类型，占两个字节，它起始地址的字节偏移量是8，满足对齐规则的2的倍数。

3、由于变量c是double类型，占8个字节，因此，该变量起始地址的偏移量需要是8的倍数，所以需要在变量b之后插入6个字节的间隙。

4、对于变量d只占一个字节，顺序排列即可。

5、由于变量e占4个字节，它的偏移量需要是4的倍数，因此，需要在变量d之后插入3个字节的间隙。

6、同样变量f是char类型，顺序排列即可。

7、由于变量g占8个字节，因此需要在变量f之后插入7个字节的间隙。

8、最后一个变量h占4个字节，此时结构体的大小为52个字节，为了保证每个元素都满足对齐要求，还需要在结构体的尾端填充4个字节的间隙。

  最终结构体的大小为56个字节

**联合体**

联合体所有字段共享一存储区域，联合体大小取决于它最大字段的大小.

**缓冲区溢出**

有栈随机化，栈破坏检测，可执行代码区域等，来避免栈溢出.

**栈随机化**

栈随机化思想是栈的位置在每次运行时都有变化.在linux64位系统上，地址范围0x7fff0001b698~0x7ffffffaa4a8，采用栈随机化机制，即使机器运行相同代码，栈地址也是不同的.

在linux系统，栈随机化已经成为标准行为，它属于地址空间布局随机化的一种.每次运行程序不同部分会被加载到内存的不同区域.

**栈破坏检测**

编译器会在产生的汇编代码中加入一种栈保护者的机制来检测缓冲区越界，就是在缓冲区与栈保存的状态值之间存储一个特殊值，这个特殊值被称作金丝雀值，之所以叫这个名字，是因为从前煤矿工人会根据金丝雀的叫声来判断煤矿中有毒气体的含量。

金丝雀值是每次程序运行时随机产生的，因此攻击者想要知道这个金丝雀值具体是什么并不容易，在函数返回之前，检测金丝雀值是否被修改来判断是否遭受攻击。

**限制可执行代码区域**

最后一种机制是消除攻击者向系统中插入可执行代码的能力，其中一种方法是限制哪些内存区域能够存放可执行代码。x86的处理器将可读和可执行的访问控制合并成一位标志，所以可读的内存页也都是可执行的，由于栈上的数据需要被读写，因此栈上的数据也是可执行的。虽然实现了一些机制能够限制一些页可读且不可执行，但是这些机制通常会带来严重的性能损失，后来，处理器的内存保护引入了不可执行位，将读和可执行访问模式分开了。有了这个特性，栈可以被标记为可读和可写，但是不可执行。检查页是否可执行由硬件来完成，效率上没有损失。


 以上这三种机制，都不需要程序员做任何额外的工作，都是通过编译器和操作系统来实现的，单独每一种机制都能降低漏洞的等级，组合起来使用会更加有效。

**浮点代码**

- 浮点数所使用的寄存器与整型所使用的`%rdi,%rsi...`不同，它们分别是`%ymm0~ymm15`，每个`%ymmX`寄存器可以保存32字节。其中`%xmmX`寄存器是`%ymmX`寄存器的低16**字节**。

  浮点数指令使用频率较低，不表.