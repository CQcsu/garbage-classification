# 五.优化程序性能

**优化编译器能力和局限性**

大多数编译器，包括 GCC，向用户提供了一些对它们所使用的优化的控制。最简单的控制就是制定`优化级别`。例如，以命令行选项 `-Og` 调用是让 GCC 使用一组基本的优化。以选项 `-O1`、`-O2` 或 `-O3` 调用将得到更多的优化。

编译器必须很小心地对程序只使用`安全的优化`，也就是说对于程序可能遇到的所有可能的情况，在 C 语言标准提供的保证之下，优化后得到的程序和未优化的版本有一样的行为。



**1.代码移动**

将循环不变量从循环中提出.

~~~c++
// 优化前
for(size_t i = 0; i < strlen(str); i++)
  Statements;
// 优化后
size_t str_len = strlen(str);
for(size_t i = 0; i < str_len; i++)
  Statements;
~~~

上面的例子中，未优化版本在某些情况下，其时间复杂度可达到O(N2)O(N2)级别！改进后的时间复杂度只有O(N)。

**2.消除不必要的内存引用（临时变量做累积值）**

代码将合并运算计算的值累积在指针 dest 指定的位置。

~~~c++
//优化前
*dest = IDENT:
data_t *data = get_vec_start(v);
for (long i = 0; i < length; ++i) {
  *dest = *dest OP data[i];  // val -> data[i]
}
//优化后
data_t acc = IDENT;  // local variable
for (long i = 0; i < length; ++i) {
  acc = acc OP data[i];
}
~~~

减少不必要的内存读写获得更高的执行速度

**3.理解现代处理器**

现代处理器使用流水线机制，同时搭配高速缓存内存以答更高的速度.避免流水线暂停或cache中数据未命中，可以让CPU尽可能地发挥出全部性能。

**4.循环展开**

循环展开是一种程序变换，通过增加每次迭代计算的运算数量，减少循环迭代的次数.

~~~c++
// 循环展开前
for(int i = 0; i < lmits; i++)
  acc0 = acc0 OP data[i];

// 循环展开后
int limits = length - n;
int i;
for(i = 0; i < lmits; i += 2)
{
  acc0 = acc0 OP data[i];
  acc0 = acc0 OP data[i+1];
}
for(; i < length; i ++)
  acc0 = acc0 OP data[i];

~~~

编译器可以很容易地执行循环展开。只要优化级别设置得足够高，许多编译器都能例行公事地做到这一点。用优化级别 3 或更高等级调用 GCC，它就会执行循环展开。

**5.提高并行性**

对于一个可结合或可交换的合并运算，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。

- 多个累积变量

  ~~~c++
  int limits = length - n;
  int i;
  for(i = 0; i < lmits; i += 2)
     {
        acc0 = acc0 OP data[i];
        acc1 = acc0 OP data[i+1];
     }
  for(; i < length; i ++)//保证最后一项
   	acc0 = acc0 OP data[i];
  int total = acc0 + acc1;
  ~~~

+ 重新结合变换

  ~~~c++
  // 1
  acc = (acc OP data[i]) OP data[i + 1];
  // 2
  acc = acc OP (data[i] OP data[i + 1]);
  ~~~

**总结**

1.高级设计

- 适当的算法和数据结构

2.基本编码原则

- 消除连续的函数调用（将计算移到循环外）
- 消除不必要的的内存引用（引入临时变量保存中间结果）

3.低级优化

- 展开循环
- 多个累积变量和重新结合（提高指令级并行）

