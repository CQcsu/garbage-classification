# 设备驱动和文件系统

**1. I/O和显示器**

![image-20220316093024050](screenshot/image-20220316093024050.png)

+ CPU向外设的控制器发出指令，然后CPU继续多进程
+ 外设准备就绪后，向CPU发出中断
+ CPU进行中断处理.

操作系统要给用户提供一个简单的视图——文件视图。

![image-20220316093143541](screenshot/image-20220316093143541.png)

![image-20220316093210219](screenshot/image-20220316093210219.png)

![image-20220316093310121](screenshot/image-20220316093310121.png)

![image-20220316093328478](screenshot/image-20220316093328478.png)

![image-20220316093345041](screenshot/image-20220316093345041.png)

+ 找到tty0，根据这个找到对应的路径，将显示器/键盘设备信息读入.
+ write处理这个设备信息.

![image-20220316093529139](screenshot/image-20220316093529139.png)

![image-20220316093549810](screenshot/image-20220316093549810.png)

![image-20220316093559452](screenshot/image-20220316093559452.png)

![image-20220316093624957](screenshot/image-20220316093624957.png)

![image-20220316093634948](screenshot/image-20220316093634948.png)

![image-20220316093649297](screenshot/image-20220316093649297.png)

![image-20220316093707218](screenshot/image-20220316093707218.png)

**2. 键盘**

![image-20220316095325120](screenshot/image-20220316095325120.png)

+ inb ，从60端口读入扫描码
+ 根据不同的扫描码，调用key_table对应操作.

![image-20220316095425051](screenshot/image-20220316095425051.png)

![image-20220316095436854](screenshot/image-20220316095436854.png)

![image-20220316095448576](screenshot/image-20220316095448576.png)

+ 放入缓冲队列中，等待con.read_q来拿

![image-20220316095525117](screenshot/image-20220316095525117.png)

**3. 生磁盘的使用**

生磁盘：怎么让磁盘工作起来，用盘块号来使用磁盘，而不是文件.

![image-20220316105421763](screenshot/image-20220316105421763.png)

+ 磁盘的单位是扇区：512字节.

![image-20220316105510157](screenshot/image-20220316105510157.png)

+ 移动磁头到磁道，旋转磁头到对应扇区.
+ 读出数据，与内存缓存区进行读写交换，完成写入.

![image-20220316105639914](screenshot/image-20220316105639914.png)

+ 柱面C，磁头H，扇区S.找到对应位置给出这个位置，利用DMA就可以读写磁盘

![image-20220316105741732](screenshot/image-20220316105741732.png)

+ 程序只发送盘块号，磁盘驱动计算出C，H，S，再来访问对应的位置.
+ 即从一维地址解码到三维地址
+ 希望block相邻盘块可以快速读出，主要时间发生再寻道上.（一般程序会访问相邻的多个地址）
+ 把相邻盘块号的盘块尽量放在相同磁道上.（放在旋转的旁边）

![image-20220316110224795](screenshot/image-20220316110224795.png)

+ 盘块是扇区的整数倍.这样设置盘块，可以一次读取多个扇区.每次读写连续的几个扇区.使用空间换书简，把内存单位变成了盘块，虽然可能浪费时间，但是会提升时间效率.

![image-20220316110417371](screenshot/image-20220316110417371.png)

+ 多个进程都要使用磁盘，增加一个请求队列.每个进程使用的block放入队列中，需要使用调度算法进行调度。让母后寻道时间尽可能小，按顺序弹出，然后进行上述过程.

![image-20220316110621709](screenshot/image-20220316110621709.png)

+ 先来先服务算法最直观，但是效率不高.

![image-20220316110705368](screenshot/image-20220316110705368.png)

+ 最短寻道时间算法，但是一些远处的请求无法到，因为中间磁道不断请求出现饥饿问题.

![image-20220316110820861](screenshot/image-20220316110820861.png)

![image-20220316110850168](screenshot/image-20220316110850168.png)

![image-20220316110900825](screenshot/image-20220316110900825.png)

**4. 从生磁盘到文件**

![image-20220316113300673](screenshot/image-20220316113300673.png)

+ 文件：建立字符流到盘块的数据集合

![image-20220316113329043](screenshot/image-20220316113329043.png)

![image-20220316113339878](screenshot/image-20220316113339878.png)

![image-20220316113358320](screenshot/image-20220316113358320.png)

![image-20220316113404804](screenshot/image-20220316113404804.png)

**5. 文件使用磁盘的实现**

![image-20220316132639044](screenshot/image-20220316132639044.png)

+ 再内部被换算成盘块号.根据字符流算出数据盘块.

![image-20220316132744298](screenshot/image-20220316132744298.png)

![image-20220316132758763](screenshot/image-20220316132758763.png)

![image-20220316132813011](screenshot/image-20220316132813011.png)

![image-20220316132823162](screenshot/image-20220316132823162.png)

![image-20220316132835412](screenshot/image-20220316132835412.png)

+ inode来决定是去磁盘，还是执行其他函数进行显示.

**6. 目录与文件系统**

![image-20220316134333386](screenshot/image-20220316134333386.png)

+ 将整个磁盘按照一定的方式组织，抽象整个磁盘.
+ 用户眼中：是目录树的结构.这种文件系统插在不同的机器，系统中都是一样的兼容.
+ 文件系统：将整个磁盘抽象成目录树的结构.

![image-20220316134538113](screenshot/image-20220316134538113.png)

![image-20220316134550513](screenshot/image-20220316134550513.png)

![image-20220316134603809](screenshot/image-20220316134603809.png)

+ 使用路径名来定位a，从树根到某个节点/目录
+ 根据路径找到文件的FCB(文件控制块)
+ 得到的FCB就是他在磁盘中的对应位置.
+ 直观的想法：目录下存放所有文件的PCB，放在这个目录下.这样查找目录时要把所有文件的字符串和PCB读入，对每个进行字符串匹配，找到匹配目标的PCB.只找一个文件需要读入所有文件的PCB，但是其实只需要匹配字符串就行.

![image-20220316134953224](screenshot/image-20220316134953224.png)

+ 我们不存放FCB，而是存放文件名字符串+对应PCB地址.(FCB数组的下标)
+ 这样匹配到字符串，再通过下标来找到对应的FCB，完成后续.

![image-20220316135149824](screenshot/image-20220316135149824.png)

+ 根目录放在inode数组的第一项(FCB数组)，前面存放一些位图.

![image-20220316135231049](screenshot/image-20220316135231049.png)

+ 目录树找到文件inode
+ 根据PCB(inode)找到对应的盘块
+ 加到电梯队列
+ 磁盘中断，算出对应盘块的磁盘物理位置
+ 进行读写.

**7. 目录解析代码实现**

![image-20220316141541966](screenshot/image-20220316141541966.png)

+ 核心就是找到inode

![image-20220316141622392](screenshot/image-20220316141622392.png)

![](screenshot/image-20220316141633942.png)

![image-20220316141658968](screenshot/image-20220316141658968.png)

+ get_super,找到前面的超级块，知道了位图的尺寸.
+ block找到对应的i节点块的位置.
+ break去磁盘里读出块.

![image-20220316141818136](screenshot/image-20220316141818136.png)

![image-20220316141828141](screenshot/image-20220316141828141.png)

+ 找到对应的目录项，进行匹配，找到就读出inode，然后继续iget循环.

**操作系统全图：**

+ 核心是多进程视图
+ CPU执行是取指执行，完成计算指令.对内存指令，需要进行重定位，段页表结合，找到内存位置.
+ CPU执行如果是open，read，write，等指令需要文件视图.
+ 文件视图执行，对目录进行解析，电梯队列排队最后得到inode.如果是I/O设备那么就需要得到设备号，完成对应输入输出操作，如果是磁盘最后得到的是磁盘上的C，H，S完成磁盘的读写.